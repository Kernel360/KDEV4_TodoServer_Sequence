객체 지향 4가지 특징
- 1. 추상화 (Abstraction) : 불필요한 부분을 제거함으로써 필요한 핵심만 나타낸 것을 추상화라고 생각한다
                         : 일반화, 단순화라고도 한다
                         : 이를 사용하는 이유는 복잡성을 낮추기 위한 도구로 추상화를 사용하는 편이다
- 2. 다형성 (Polymorphism) : 다양한 형태를 가지는 것
                          : 쉽게 말해 하나의 타입으로 여러 종류의 객체를 참조하는 것
- 3. 캡슐화 (Encapsulation) : 객체 내부의 세부사항을 외부로부터 감추는 것
                           : 캡슐화의 목적은 인터페이스만 공개해서 변경하기 쉬운 코드를 만들기 위한 것
- 4. 상속 (Inheritance) : 부모로부터 물려받는 것

객체지향의 5가지 설계 원칙(SOLID)
1. SRP : Single Responsibility Principle ( 단일 책임의 원칙 ) -> 하나의 책임을 가진다
2. OCP : Open/Closed Principle ( 개방 폐쇄의 원칙 ) -> 기존 코드를 변경하지 않고 기능을 추가할 수 있어야 한다는 원칙
3. LSP : Liskov's Substitution Principle ( 리스코프 치환의 원칙 ) -> 상위 타입의 객체를 하위 타입의 객체로 치환해도 동작에 전혀 문제가 없어야 한다
4. ISP : Interface Segregation Principle ( 인터페이스 분리의 원칙 ) -> 많은 기능을 가진 인터페이스를 작은 단위로 분리시킴으로써 클라이언트에게 필요한 인터페이스들만 구현하도록 한다
                                                                   이를 통해 클라이언트가 사용하지 않는 기능에 의존하게 되면 예상하지 못한 문제가 발생할 수 있는데 이를 예방할 수 있음
5. DIP : Dependency Inversion Principle ( 의존성 역전의 원칙 ) -> 의존관계를 맺을 때 자주 변경되는 쪽이 아니라 변경이 거의 일어나지 않는 쪽에 위존하라는 의미이며,
                                                               자기보다 변하기 쉬운 것에 의존하게 되면 변화의 영향을 많이 받기 때문에
                                                               추상화된 인터페이스나 상위 클래스를 둬서 변화의 영향을 받지 않게 하기 위한 원칙

객체지향 이란?
- 적절한 객체에게 적절한 책임을 할당하여 서로 메시지를 주고받으며 협력하도록 하는 것

객체지향 패러다임
- 적절한 객체에게 적절한 책임을 할당하여 서로 메시지를 주고 받으며 협력하도록 하는 것
- 점점 증가하는 SW 복잡도를 낮추기 위해 객체지향 패러다임 대두
- 클래스가 아닌 객체에 초점을 맞추는 것
- 객체들에게 얼마나 적절한 역할과 책임을 할당하는지

절차지향 프로그래밍 vs 객체지향 프로그래밍
- 책임이 한 곳에 집중돼 있는 방식(getter) -> 절차지향
                                     -> 하나의 메서드에서 getter 를 통해 값을 가지고 온 다음에 이곳에서
                                        어떠한 모든 처리가 집중되어 있다면 절차 지향 방식
- 책임이 여러 객체로 적절히 분산돼 있는 방식 -> 객체지향

객체지향 설계 및 구현
- high cohesion, loose coupling : 높은 응집도와 낮은 결합도 (서랍정리??)
                                : 즉, 응집도가 높은 비슷한 것들은 하나로 모아두고 다른 성격의 것들은 분리시킴으로써
                                  비슷한 것들끼리는 응집도를 높이고 한 곳에 모아두고 다른 것들끼리는 분리를 시킨다
                                : 응집도가 높은 것들 끼리 모아두면 어떠한 변경이 생겼을 때 변경의 포인트가 하나로 집중 될 수 있다
                                : 객체지향에 있어서 변경에 대한 요구사항이 들어왔을 때 특정 한 부분만 수정을 하면 된다는 것은 응집도 높다
                                : 어떠한 변경이 생겼을 때 다른 곳에 영향을 미치지 않는다면 낮은 결합도라고 생각든다
- 객체지향을 설계한다는 것은 어떠한 변경이 생겼을 때 아주 빠르게 그리고 높은 응집도와 낮은 결합도를 가지고 유연하게 대응할 수 있음을 의미한다


객체지향 설계 순서
- 1. 도메인을 구성하는 객체에는 어떤 것들이 있는지 고민
- 2. 객체들 간의 관계를 고민
- 3. 동적인 객체를 정적인 타입으로 추상화해서 도메인 모델링 하기
     -> 객체들이 어떤 상태와 행동을 가지는지 결정이 되면 공통적인 상태와 행동을 가진 객체들을 타입으로 분류할 수 있다
        이 타입을 기반으로 클래스를 구현하는 편
     -> 즉 클래스는 공통적인 상태와 행동을 가지는 객체들을 추상화한 것
- 4. 협력을 설계
- 5. 객체들을 포괄하는 타입에 적절한 책임을 할당 ( 클래스에 적절한 책임을 할당 )
    -> 클라이언트와 협력할 수 있는 퍼블릭 인터페이스를 정의한다고 생각하면 좋다
- 6. 구현하기 -> 퍼블릭 인터페이스 구현

- 객체지향 세계에서는 모든 객체가 능동적인 존재이다
