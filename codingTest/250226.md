## 문제
https://www.acmicpc.net/problem/20164

- 난이도: 2
- 1 <= N < 10<sup>9</sup>

## 풀이

- 완전 탐색 접근
- 수가 9자리이기 때문에 전부 다 해보아도 경우의 수가 많지 않음.
- 완전 탐색 => 주로 재귀함수
- 우선, 함수 디자인부터 하기
  1. 매 순간 들고 있는 수, x
  2. 시작부터 지금까지 얻은 점수, total_odd_cnt
- 재귀 함수 조건
  - 종료 조건 => x가 한 자리 수일 때
- 수가 3개로 나눠지고 합쳐질 때마다 크기가 매우 작아지기 때문에 모든 경우의 수가 1억을 절대 넘지 않음을 알 수 있습니다.

```java
import static java.lang.Integer.max;
import static java.lang.Integer.min;

public class Main {
	static int N, ans_min, ans_max;
	static PrintWriter out = new PrintWriter(System.out);

	public static void main(String[] args) {
		input();
		pro();
	}

	static void input(){
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		N = Integer.parseInt(br.readLine());
	}

	static void pro(){
		ans_min = 0x7fffffff;
		ans_max = 0;

		dfs(N, get_odd_cnt(N));
		System.out.println(ans_min + " " + ans_max);
	}

	// x 라는 수 안에 홀수의 개수를 return
	static int get_odd_cnt(int x){
		int res = 0;
		while (x > 0){
			int digit = x % 10;
			if (digit % 2 == 1) res++;
			x /= 10;
		}
		return res;
	}

	// 이때까지 등장한 홀수 자릿수가 total_odd_cnt 만큼 있을 때, 남은 경우를 모두 잘라보는 함수
	static void dfs(int x, int total_odd_cnt) {
		// 만약 한 자리 수면 더 이상 작업을 반복할 수 없으므로 정답을 갱신하고 종료
		if (x <= 9) {
			ans_min = min(ans_min, total_odd_cnt);
			ans_max = max(ans_max, total_odd_cnt);
			return;
		}

		// 만약 두 자리 수면 2개로 나눠서 재귀 호출
		if (x <= 99) {
			int next_x = (x / 10) + (x % 10);
			dfs(next_x, get_odd_cnt(next_x) + total_odd_cnt);
			return;
		}

		// 만약 세 자리 이상의 수면 가능한 3가지 자르는 방법을 모두 진행
		String s = String.valueOf(x);
		for (int i = 0; i <= s.length() - 3; i++) {
			for (int j = i + 1; j <= s.length() - 2; j++) {
				String x1 = s.substring(0, i + 1);  // s[0 ... i]
				String x2 = s.substring(i + 1, j + 1);  // s[i+1 ... j]
				String x3 = s.substring(j + 1, s.length());  // s[j+1 ... end]

				// 나눠진 세 수를 더해서 재귀 호출
				int next_x = Integer.parseInt(x1) + Integer.parseInt(x2) + Integer.parseInt(x3);
				dfs(next_x, get_odd_cnt(next_x) + total_odd_cnt);
			}
		}
	}
}
```